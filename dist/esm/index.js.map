{"version":3,"sources":["../../src/client.ts","../../src/constants/coin.ts","../../src/constants/object.ts","../../src/utils/format.ts","../../src/utils/coin.ts","../../src/utils/object.ts","../../src/utils/response.ts","../../src/builder.ts"],"sourcesContent":["import {\n  Transaction,\n  TransactionArgument,\n  TransactionResult,\n} from \"@iota/iota-sdk/transactions\";\nimport { getFullnodeUrl, IotaClient } from \"@iota/iota-sdk/client\";\n\nimport {\n  CDP_PACKAGE_ID,\n  CDP_VERSION_OBJ,\n  CLOCK_OBJ,\n  COINS_TYPE_LIST,\n  FRAMEWORK_PACKAGE_ID,\n  ORACLE_PACKAGE_ID,\n  TESTNET_PRICE_FEED_OBJ,\n  TESTNET_PRICE_PACKAGE_ID,\n  TREASURY_OBJ,\n  VAULT_MAP,\n} from \"@/constants\";\nimport {\n  VaultInfo,\n  VaultResponse,\n  COLLATERAL_COIN,\n  PositionInfo,\n  VaultInfoList,\n  PositionResponse,\n} from \"@/types\";\nimport {\n  getObjectFields,\n  getPriceResultType,\n  parsePositionObject,\n  parseVaultObject,\n} from \"@/utils\";\n\nconst DUMMY_ADDRESS = \"0x0\";\n\nexport class VirtueClient {\n  /**\n   * @description a TS wrapper over Virtue CDP client.\n   * @param network connection to fullnode: 'mainnet' | 'testnet' | 'devnet' | 'localnet' | string\n   * @param owner (optional) address of the current user (default: DUMMY_ADDRESS)\n   */\n  private rpcEndpoint: string;\n  private client: IotaClient;\n\n  constructor(\n    public network: string = \"mainnet\",\n    public owner: string = DUMMY_ADDRESS,\n  ) {\n    if (\n      network == \"mainnet\" ||\n      network == \"testnet\" ||\n      network == \"devnet\" ||\n      network == \"localnet\"\n    ) {\n      this.rpcEndpoint = getFullnodeUrl(network);\n    } else {\n      this.rpcEndpoint = network as string;\n    }\n\n    this.client = new IotaClient({ url: this.rpcEndpoint });\n  }\n\n  getClient() {\n    return this.client;\n  }\n\n  // Query\n  /**\n   * @description Get all vault objects\n   */\n  async getAllVaults(): Promise<VaultInfoList> {\n    // Get objectId from VAULT_MAP and get all vaults\n    const vaultObjectIds = Object.values(VAULT_MAP).map(\n      (v) => v.vault.objectId,\n    );\n    const vaultResults = await this.client.multiGetObjects({\n      ids: vaultObjectIds,\n      options: {\n        showContent: true,\n      },\n    });\n\n    const vaults: VaultInfoList = vaultResults.reduce((acc, res) => {\n      const fields = getObjectFields(res) as VaultResponse;\n      const token = Object.keys(VAULT_MAP).find(\n        (key) =>\n          VAULT_MAP[key as COLLATERAL_COIN].vault.objectId ===\n          res.data?.objectId,\n      );\n      if (!token) return acc;\n\n      const vault = parseVaultObject(token as COLLATERAL_COIN, fields);\n      acc[vault.token] = vault;\n      return acc;\n    }, {} as VaultInfoList);\n\n    return vaults;\n  }\n\n  /**\n   * @description Get Vault<token> object\n   */\n  async getVault(token: COLLATERAL_COIN): Promise<VaultInfo> {\n    const res = await this.client.getObject({\n      id: VAULT_MAP[token].vault.objectId,\n      options: {\n        showContent: true,\n      },\n    });\n    const fields = getObjectFields(res) as VaultResponse;\n\n    return parseVaultObject(token, fields);\n  }\n\n  async getPositionsByDebtor(debtor: string): Promise<PositionInfo[]> {\n    const vaults = await this.getAllVaults();\n    const positions: PositionInfo[] = [];\n    for (const vault of Object.values(vaults)) {\n      const tableId = vault.bottleTableId;\n      const res = await this.client.getDynamicFieldObject({\n        parentId: tableId,\n        name: {\n          type: \"address\",\n          value: debtor,\n        },\n      });\n      const obj = getObjectFields(res);\n      if (!obj) continue;\n\n      const response = obj.value.fields.value as PositionResponse;\n      const position = parsePositionObject(response);\n      if (position) {\n        positions.push(position);\n      }\n    }\n\n    return positions;\n  }\n\n  async getPosition(\n    debtor: string,\n    collateral: COLLATERAL_COIN,\n  ): Promise<PositionInfo | undefined> {\n    const vaultInfo = await this.getVault(collateral);\n    const tableId = vaultInfo.bottleTableId;\n    const res = await this.client.getDynamicFieldObject({\n      parentId: tableId,\n      name: {\n        type: \"address\",\n        value: debtor,\n      },\n    });\n    const obj = getObjectFields(res);\n    if (!obj) return;\n\n    const response = getObjectFields(\n      obj.value.fields.value,\n    ) as PositionResponse;\n    return parsePositionObject(response);\n  }\n\n  /**\n   * @description Create a price collector\n   * @param collateral coin symbol, e.g \"IOTA\"\n   */\n  newPriceCollector(\n    tx: Transaction,\n    coinSymbol: COLLATERAL_COIN,\n  ): TransactionResult {\n    return tx.moveCall({\n      target: `${ORACLE_PACKAGE_ID}::collector::new`,\n      typeArguments: [COINS_TYPE_LIST[coinSymbol]],\n    });\n  }\n\n  /**\n   * @description Get a price result\n   * @param collateral coin symbol, e.g \"IOTA\"\n   */\n  aggregatePrice(\n    tx: Transaction,\n    coinSymbol: COLLATERAL_COIN,\n  ): TransactionResult {\n    const [collector] = this.newPriceCollector(tx, coinSymbol);\n    const coinType = COINS_TYPE_LIST[coinSymbol];\n    // TODO: testnet only\n    tx.moveCall({\n      target: `${TESTNET_PRICE_PACKAGE_ID}::testnet_price::self_price`,\n      typeArguments: [coinType],\n      arguments: [tx.sharedObjectRef(TESTNET_PRICE_FEED_OBJ), collector],\n    });\n\n    // aggregate\n    const aggregater = tx.sharedObjectRef(\n      VAULT_MAP[coinSymbol].priceAggregater,\n    );\n    return tx.moveCall({\n      target: `${ORACLE_PACKAGE_ID}::aggregater::aggregate`,\n      typeArguments: [coinType],\n      arguments: [aggregater, collector],\n    });\n  }\n\n  /**\n   * @description Get a request to Mange Position\n   * @param tx\n   * @param collateral coin symbol , e.g \"IOTA\"\n   * @param collateral input coin\n   * @param the amount to borrow\n   * @param repyment input coin (always VUSD)\n   * @param the amount to withdraw\n   * @returns ManageRequest\n   */\n  requestManagePosition(\n    tx: Transaction,\n    coinSymbol: COLLATERAL_COIN,\n    depositCoin: TransactionArgument,\n    borrowAmount: string,\n    repaymentCoin: TransactionArgument,\n    withdrawAmount: string,\n    accountObj?: string | TransactionArgument,\n  ) {\n    const coinType = COINS_TYPE_LIST[coinSymbol];\n    const [accountReq] = accountObj\n      ? tx.moveCall({\n          target: `${FRAMEWORK_PACKAGE_ID}::account::request_with_account`,\n          arguments: [\n            typeof accountObj === \"string\" ? tx.object(accountObj) : accountObj,\n          ],\n        })\n      : tx.moveCall({\n          target: `${FRAMEWORK_PACKAGE_ID}::account::request`,\n        });\n    return tx.moveCall({\n      target: `${CDP_PACKAGE_ID}::manage::request`,\n      typeArguments: [coinType],\n      arguments: [\n        tx.sharedObjectRef(CDP_VERSION_OBJ),\n        accountReq,\n        depositCoin,\n        tx.pure.u64(borrowAmount),\n        repaymentCoin,\n        tx.pure.u64(withdrawAmount),\n      ],\n    });\n  }\n\n  /**\n   * @description Manage Position\n   * @param tx\n   * @param collateral coin symbol , e.g \"IOTA\"\n   * @param manager request, see this.requestManagePosition\n   * @param price result, see this.getPriceResult\n   * @param the position place to insert\n   * @returns [Coin<T>, COIN<VUSD>]\n   */\n  managePosition(\n    tx: Transaction,\n    coinSymbol: COLLATERAL_COIN,\n    manageRequest: TransactionArgument,\n    priceResult?: TransactionArgument,\n    insertionPlace?: string,\n  ): TransactionResult {\n    const vault = VAULT_MAP[coinSymbol].vault;\n    const priceResultOpt = priceResult\n      ? tx.moveCall({\n          target: `0x1::option::some`,\n          typeArguments: [getPriceResultType(coinSymbol)],\n          arguments: [priceResult],\n        })\n      : tx.moveCall({\n          target: `0x1::option::none`,\n          typeArguments: [getPriceResultType(coinSymbol)],\n        });\n    return tx.moveCall({\n      target: `${CDP_PACKAGE_ID}::vault::manage_position`,\n      typeArguments: [COINS_TYPE_LIST[coinSymbol]],\n      arguments: [\n        tx.sharedObjectRef(vault),\n        tx.sharedObjectRef(CDP_VERSION_OBJ),\n        tx.sharedObjectRef(TREASURY_OBJ),\n        tx.sharedObjectRef(CLOCK_OBJ),\n        priceResultOpt,\n        manageRequest,\n        tx.pure.option(\"address\", insertionPlace),\n      ],\n    });\n  }\n}\n","import { COIN } from \"@/types\";\n\nexport const COINS_TYPE_LIST: Record<COIN, string> = {\n  IOTA: \"0x0000000000000000000000000000000000000000000000000002::iota::IOTA\",\n  stIOTA:\n    \"0x1461ef74f97e83eb024a448ab851f980f4e577a97877069c72b44b5fe9929ee3::cert::CERT\",\n  VUSD: \"0x929065320c756b8a4a841deeed013bd748ee45a28629c4aaafc56d8948ebb081::vusd::VUSD\",\n};\n\nexport const COIN_DECIMALS: Record<COIN, number> = {\n  IOTA: 9,\n  stIOTA: 9,\n  VUSD: 6,\n};\n","import { COLLATERAL_COIN } from \"@/types\";\nimport { SharedObjectRef } from \"@iota/iota-sdk/dist/cjs/bcs/types\";\n\n/// Original Package IDs\n\nexport const ORIGINAL_FRAMEWORK_PACKAGE_ID =\n  \"0x6f8dd0377fe5469cd3456350ca13ae1799655fda06e90191b73ab1c0c0165e8f\";\nexport const ORIGINAL_VUSD_PACKAGE_ID =\n  \"0x929065320c756b8a4a841deeed013bd748ee45a28629c4aaafc56d8948ebb081\";\nexport const ORIGINAL_ORACLE_PACKAGE_ID =\n  \"0x3eb4e0b2c57fe9844db30c6bb2b775ed18fd775dd9d48955b78bcd0ac0ba8954\";\nexport const ORIGINAL_CDP_PACKAGE_ID =\n  \"0x0731a9f5cbdb0a4aea3f540280a1a266502017867734240e29edc813074e7f60\";\n\n/// Latest Package IDs\n\nexport const FRAMEWORK_PACKAGE_ID =\n  \"0x6f8dd0377fe5469cd3456350ca13ae1799655fda06e90191b73ab1c0c0165e8f\";\nexport const VUSD_PACKAGE_ID =\n  \"0x929065320c756b8a4a841deeed013bd748ee45a28629c4aaafc56d8948ebb081\";\nexport const ORACLE_PACKAGE_ID =\n  \"0xbc672e6330ab22078715f86e952ef1353d9f9b217c4579e47ce29eaec6f92655\";\nexport const CDP_PACKAGE_ID =\n  \"0x229091f5fcf75c094372671ca58caa074c90f99c8975e145b3ffc3d23e49a493\";\n\n/// Shared Objects\n\nexport const CLOCK_OBJ = {\n  objectId:\n    \"0x0000000000000000000000000000000000000000000000000000000000000006\",\n  mutable: false,\n  initialSharedVersion: 1,\n};\n\nexport const TREASURY_OBJ = {\n  objectId:\n    \"0x4e2e41f0158bce26c8e8ccc62be3ab5326d8b294a2bcccfbe0e7298885f66eb7\",\n  mutable: true,\n  initialSharedVersion: 190869396,\n};\n\nexport const CDP_VERSION_OBJ = {\n  objectId:\n    \"0xb67e79921b2b71e77e5bd1adf28c9d47a8ad5bd22e024bbd90797514c39b068d\",\n  mutable: false,\n  initialSharedVersion: 190869403,\n};\n\nexport type VaultObjectInfo = {\n  // symbol: COIN;\n  priceAggregater: SharedObjectRef;\n  vault: SharedObjectRef;\n};\n\nexport const VAULT_MAP: Record<COLLATERAL_COIN, VaultObjectInfo> = {\n  IOTA: {\n    priceAggregater: {\n      objectId:\n        \"0x9f3c9d72993efd5e2e543ad69bdc0bbe1bd9873c3a61fdf32c0cf48660a5f2c8\",\n      mutable: true,\n      initialSharedVersion: 190869399,\n    },\n    vault: {\n      objectId:\n        \"0xbbf7b7667aca64405e8756f6974f41bd648bd1bc40dfc2b1cfe2d6ec419eedb1\",\n      mutable: true,\n      initialSharedVersion: 237544284,\n    },\n  },\n  stIOTA: {\n    priceAggregater: {\n      objectId:\n        \"0x0898681c27fa8912905f97a9803c63d7e56abcbac7175f686325eddb215efebd\",\n      mutable: true,\n      initialSharedVersion: 246871816,\n    },\n    vault: {\n      objectId:\n        \"0xc6b28c98e0c1c6fa282affd3b8db8e9a5ed143aed4e3b5bd1d1bc6f34dad3861\",\n      mutable: true,\n      initialSharedVersion: 246871815,\n    },\n  },\n};\n\n// only on testnet\nexport const TESTNET_PRICE_PACKAGE_ID =\n  \"0x2de2d918f5940978dc53aae2ea0687a4ca8a6736bd525f15ee17e9529048fa92\";\nexport const TESTNET_PRICE_FEED_OBJ = {\n  objectId:\n    \"0x05cc35b8d331a3893f80b9ca6c70c3b75298e9cbf1b5d707b6d18c40b0b3da5d\",\n  mutable: false,\n  initialSharedVersion: 190869400,\n};\n","import { COIN, COLLATERAL_COIN } from \"@/types\";\nimport { COINS_TYPE_LIST, ORIGINAL_ORACLE_PACKAGE_ID } from \"@/constants\";\n\nexport function getObjectNames(objectTypes: string[]) {\n  const accept_coin_type = Object.values(COINS_TYPE_LIST);\n  const accept_coin_name = Object.keys(COINS_TYPE_LIST);\n\n  const coinTypeList = objectTypes.map(\n    (type) => type.split(\"<\").pop()?.replace(\">\", \"\") ?? \"\",\n  );\n\n  const objectNameList: string[] = [];\n\n  coinTypeList.forEach((type) => {\n    const typeIndex = accept_coin_type.indexOf(type);\n    const coinName = accept_coin_name[typeIndex];\n    objectNameList.push(coinName ?? \"\");\n  });\n\n  return objectNameList;\n}\n\nexport const getCoinType = (str: string) => {\n  const startIndex = str.indexOf(\"<\");\n  const endIndex = str.lastIndexOf(\">\");\n\n  if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {\n    const coinType = str.slice(startIndex + 1, endIndex);\n    return coinType === \"0x2::iota::IOTA\" ? COINS_TYPE_LIST.IOTA : coinType;\n  }\n\n  return null;\n};\n\nexport const getCoinSymbol = (coinType: string) => {\n  const coin = Object.keys(COINS_TYPE_LIST).find(\n    (key) => COINS_TYPE_LIST[key as COIN] === coinType,\n  );\n  if (coin) {\n    return coin as COIN;\n  }\n  return undefined;\n};\n\nexport function U64FromBytes(x: number[]) {\n  let u64 = BigInt(0);\n  for (let i = x.length - 1; i >= 0; i--) {\n    u64 = (u64 << BigInt(8)) | BigInt(x[i] ?? 0);\n  }\n  return u64;\n}\n\nexport const formatUnits = (value: bigint, decimals: number) => {\n  let display = value.toString();\n\n  const negative = display.startsWith(\"-\");\n  if (negative) display = display.slice(1);\n\n  display = display.padStart(decimals, \"0\");\n\n  const integer = display.slice(0, display.length - decimals);\n  let fraction = display.slice(display.length - decimals);\n\n  fraction = fraction.replace(/(0+)$/, \"\");\n  return `${negative ? \"-\" : \"\"}${integer || \"0\"}${\n    fraction ? `.${fraction}` : \"\"\n  }`;\n};\n\nexport const formatBigInt = (value: string, decimals: number = 9) => {\n  const formatted = formatUnits(BigInt(value), decimals);\n  return Number(formatted);\n};\n\nexport const parseUnits = (value: number | string, decimals: number) => {\n  let [integer, fraction = \"0\"] =\n    typeof value == \"string\" ? value.split(\".\") : value.toString().split(\".\");\n\n  if (integer === undefined) {\n    return BigInt(0);\n  }\n  const negative = integer.startsWith(\"-\");\n  if (negative) integer = integer.slice(1);\n\n  // trim leading zeros.\n  fraction = fraction.replace(/(0+)$/, \"\");\n\n  // round off if the fraction is larger than the number of decimals.\n  if (decimals === 0) {\n    integer = `${Math.round(Number(`${integer}.${fraction}`))}`;\n    fraction = \"\";\n  } else if (fraction.length > decimals) {\n    const [before, after] = [\n      fraction.slice(0, decimals),\n      fraction.slice(decimals),\n    ];\n    fraction = `${\n      /^0+$/.test(before) ? before.slice(0, before.length - 1) : \"\"\n    }${Math.round(Number(`${before}.${after}`))}`;\n  } else {\n    fraction = fraction.padEnd(decimals, \"0\");\n  }\n\n  return BigInt(`${negative ? \"-\" : \"\"}${integer}${fraction}`);\n};\n\nexport const getPriceResultType = (coinSymbol: COLLATERAL_COIN): string => {\n  return `${ORIGINAL_ORACLE_PACKAGE_ID}::result::PriceResult<${COINS_TYPE_LIST[coinSymbol]}>`;\n};\n","import { IotaClient } from \"@iota/iota-sdk/client\";\nimport {\n  Transaction,\n  TransactionArgument,\n  TransactionResult,\n} from \"@iota/iota-sdk/transactions\";\n\nimport { COINS_TYPE_LIST } from \"@/constants\";\n\nexport function coinIntoBalance(\n  tx: Transaction,\n  coinType: string,\n  coinInput: TransactionArgument | undefined,\n): TransactionResult {\n  if (coinInput) {\n    return tx.moveCall({\n      target: \"0x2::coin::into_balance\",\n      typeArguments: [coinType],\n      arguments: [coinInput],\n    });\n  } else {\n    return tx.moveCall({\n      target: \"0x2::balance::zero\",\n      typeArguments: [coinType],\n    });\n  }\n}\n\nexport function coinFromBalance(\n  tx: Transaction,\n  coinType: string,\n  balanceInput: TransactionArgument,\n): TransactionResult {\n  return tx.moveCall({\n    target: \"0x2::coin::from_balance\",\n    typeArguments: [coinType],\n    arguments: [balanceInput],\n  });\n}\n\nexport async function getInputCoins(\n  tx: Transaction,\n  client: IotaClient,\n  owner: string,\n  coinType: string,\n  ...amounts: string[]\n) {\n  let isZero = true;\n  for (const amount of amounts) {\n    if (Number(amount) > 0) {\n      isZero = false;\n      break;\n    }\n  }\n\n  if (isZero) {\n    return tx.moveCall({\n      target: `0x2::coin::zero`,\n      typeArguments: [coinType],\n    });\n  }\n\n  if (coinType === COINS_TYPE_LIST.IOTA) {\n    return tx.splitCoins(\n      tx.gas,\n      amounts.map((amount) => tx.pure.u64(amount)),\n    );\n  } else {\n    const { data: userCoins } = await client.getCoins({ owner, coinType });\n    const [mainCoin, ...otherCoins] = userCoins.map((coin) =>\n      tx.objectRef({\n        objectId: coin.coinObjectId,\n        version: coin.version,\n        digest: coin.digest,\n      }),\n    );\n    if (!mainCoin) {\n      return tx.moveCall({\n        target: `0x2::coin::zero`,\n        typeArguments: [coinType],\n      });\n    }\n\n    if (otherCoins.length > 0) tx.mergeCoins(mainCoin, otherCoins);\n\n    return tx.splitCoins(\n      mainCoin,\n      amounts.map((amount) => tx.pure.u64(amount)),\n    );\n  }\n}\n\nexport async function getMainCoin(\n  tx: Transaction,\n  client: IotaClient,\n  owner: string,\n  coinType: string,\n) {\n  if (coinType === COINS_TYPE_LIST.IOTA) {\n    return undefined;\n  }\n\n  const { data: userCoins } = await client.getCoins({ owner, coinType });\n  const [mainCoin, ...otherCoins] = userCoins.map((coin) =>\n    tx.objectRef({\n      objectId: coin.coinObjectId,\n      version: coin.version,\n      digest: coin.digest,\n    }),\n  );\n  if (!mainCoin) {\n    return tx.moveCall({\n      target: `0x2::coin::zero`,\n      typeArguments: [coinType],\n    });\n  }\n\n  if (otherCoins.length > 0) tx.mergeCoins(mainCoin, otherCoins);\n  return mainCoin;\n}\n","import {\n  IotaMoveObject,\n  IotaObjectData,\n  IotaObjectResponse,\n  IotaParsedData,\n} from \"@iota/iota-sdk/client\";\nimport type { Infer } from \"superstruct\";\nimport { any, record, string } from \"superstruct\";\n\nexport const ObjectContentFields = record(string(), any());\nexport type ObjectContentFields = Infer<typeof ObjectContentFields>;\n\nexport interface IotaObjectDataWithContent extends IotaObjectData {\n  content: IotaParsedData;\n}\n\nfunction isIotaObjectDataWithContent(\n  data: IotaObjectData,\n): data is IotaObjectDataWithContent {\n  return data.content !== undefined;\n}\n\nexport function getIotaObjectData(\n  resp: IotaObjectResponse,\n): IotaObjectData | null | undefined {\n  return resp.data;\n}\n\nexport function getMoveObject(\n  data: IotaObjectResponse | IotaObjectData,\n): IotaMoveObject | undefined {\n  const obj =\n    \"data\" in data ? getIotaObjectData(data) : (data as IotaObjectData);\n\n  if (\n    !obj ||\n    !isIotaObjectDataWithContent(obj) ||\n    obj.content.dataType !== \"moveObject\"\n  ) {\n    return undefined;\n  }\n\n  return obj.content as IotaMoveObject;\n}\n\nexport function getObjectFields(\n  resp: IotaObjectResponse | IotaMoveObject | IotaObjectData,\n): ObjectContentFields | undefined {\n  if (\"fields\" in resp) {\n    return resp.fields;\n  }\n\n  return getMoveObject(resp)?.fields;\n}\n\nexport const getObjectGenerics = (resp: IotaObjectResponse): string[] => {\n  const objType = resp.data?.type;\n\n  const startIdx = objType?.indexOf?.(\"<\");\n  const endIdx = objType?.lastIndexOf?.(\">\");\n\n  return startIdx ? objType!.slice(startIdx + 1, endIdx).split(\", \") : [];\n};\n","import {\n  COLLATERAL_COIN,\n  PositionInfo,\n  PositionResponse,\n  VaultInfo,\n  VaultResponse,\n} from \"@/types\";\nimport { formatBigInt, getCoinSymbol, getCoinType } from \"./format\";\n\n// Convert response into vault object\nexport const parseVaultObject = (\n  coinSymbol: COLLATERAL_COIN,\n  fields: VaultResponse,\n): VaultInfo => {\n  const vault = {\n    token: coinSymbol,\n    bottleTableSize: fields.position_table.fields.table.fields.size,\n    bottleTableId: fields.position_table.fields.table.fields.id.id,\n    collateralDecimal: Number(fields.decimal),\n    collateralVault: fields.balance,\n    latestRedemptionTime: Number(fields.position_table.fields.timestamp),\n    mintedAmount: fields.limited_supply.fields.supply,\n    maxMintAmount: fields.limited_supply.fields.limit,\n    baseFeeRate: formatBigInt(\n      fields.position_table.fields.fee_rate.fields.value ?? 3_000_000,\n    ),\n    minCollateralRatio: formatBigInt(\n      fields.liquidation_config.fields.mcr.fields.value,\n    ),\n    recoveryModeThreshold: formatBigInt(\n      fields.liquidation_config.fields.ccr.fields.value,\n    ),\n    minBottleSize: fields.min_debt_amount,\n  };\n\n  return vault;\n};\n\n// Convert response into position object\nexport const parsePositionObject = (\n  resp: PositionResponse,\n): PositionInfo | undefined => {\n  const collateral = getCoinSymbol(getCoinType(resp.type) ?? \"\");\n  if (!collateral) {\n    return;\n  }\n\n  return {\n    collateral: collateral as COLLATERAL_COIN,\n    collAmount: resp.fields.coll_amount,\n    debtAmount: resp.fields.debt_amount,\n  };\n};\n","import { Transaction } from \"@iota/iota-sdk/transactions\";\nimport { COINS_TYPE_LIST } from \"@/constants\";\nimport { VirtueClient } from \"@/client\";\nimport { COLLATERAL_COIN } from \"@/types\";\nimport { getInputCoins } from \"@/utils\";\n\n/* ----- Manage Position Builder ----- */\nexport async function buildManagePositionTx(\n  client: VirtueClient,\n  tx: Transaction,\n  sender: string,\n  collateralSymbol: COLLATERAL_COIN,\n  collateralAmount: string,\n  borrowAmount: string,\n  repaymentAmount: string,\n  withrawAmount: string,\n  insertionPlace?: string,\n  accountObjId?: string,\n  recipient?: string,\n) {\n  const iotaClient = client.getClient();\n  const coinType = COINS_TYPE_LIST[collateralSymbol];\n  const [depositCoin] = await getInputCoins(\n    tx,\n    iotaClient,\n    sender,\n    coinType,\n    collateralAmount,\n  );\n  const [repaymentCoin] = await getInputCoins(\n    tx,\n    iotaClient,\n    sender,\n    COINS_TYPE_LIST.VUSD,\n    repaymentAmount,\n  );\n  const [priceResult] =\n    Number(borrowAmount) > 0 || Number(withrawAmount) > 0\n      ? client.aggregatePrice(tx, collateralSymbol)\n      : [undefined];\n  const [manageRequest] = client.requestManagePosition(\n    tx,\n    collateralSymbol,\n    depositCoin,\n    borrowAmount,\n    repaymentCoin,\n    withrawAmount,\n    accountObjId,\n  );\n  const [collCoin, vusdCoin] = client.managePosition(\n    tx,\n    collateralSymbol,\n    manageRequest,\n    priceResult,\n    insertionPlace,\n  );\n  tx.transferObjects([collCoin, vusdCoin], recipient ?? sender);\n}\n"],"mappings":"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","names":[]}