{"version":3,"sources":["/Users/Justa/Desktop/iota-projects/virtue-cdp/virtue-sdk/dist/index.js","../src/client.ts","../src/constants/coin.ts","../src/constants/object.ts","../src/utils/format.ts","../src/utils/coin.ts","../src/utils/object.ts","../src/utils/response.ts","../src/builder.ts"],"names":[],"mappings":"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","file":"/Users/Justa/Desktop/iota-projects/virtue-cdp/virtue-sdk/dist/index.js","sourcesContent":[null,"import {\n  Transaction,\n  TransactionArgument,\n  TransactionResult,\n} from \"@iota/iota-sdk/transactions\";\nimport { getFullnodeUrl, IotaClient } from \"@iota/iota-sdk/client\";\n\nimport {\n  CDP_PACKAGE_ID,\n  CDP_VERSION_OBJ,\n  CLOCK_OBJ,\n  COINS_TYPE_LIST,\n  FRAMEWORK_PACKAGE_ID,\n  LIQUIDATION_PACKAGE_ID,\n  ORACLE_PACKAGE_ID,\n  ORIGINAL_LIQUIDATION_PACKAGE_ID,\n  STABILITY_POOL_OBJ,\n  TESTNET_PRICE_FEED_OBJ,\n  TESTNET_PRICE_PACKAGE_ID,\n  TREASURY_OBJ,\n  VAULT_MAP,\n} from \"@/constants\";\nimport {\n  VaultInfo,\n  VaultResponse,\n  COLLATERAL_COIN,\n  PositionInfo,\n  VaultInfoList,\n  PositionResponse,\n  PriceMapResponse,\n  COIN,\n  StabilityPoolBalances,\n  StabilityPoolFields,\n} from \"@/types\";\nimport {\n  formatBigInt,\n  getCoinSymbol,\n  getObjectFields,\n  getPriceResultType,\n  parsePositionObject,\n  parseVaultObject,\n} from \"@/utils\";\n\nconst DUMMY_ADDRESS = \"0x0\";\n\nexport class VirtueClient {\n  /**\n   * @description a TS wrapper over Virtue CDP client.\n   * @param network connection to fullnode: 'mainnet' | 'testnet' | 'devnet' | 'localnet' | string\n   * @param owner (optional) address of the current user (default: DUMMY_ADDRESS)\n   */\n  private rpcEndpoint: string;\n  private client: IotaClient;\n\n  constructor(\n    public network: string = \"mainnet\",\n    public owner: string = DUMMY_ADDRESS,\n  ) {\n    if (\n      network == \"mainnet\" ||\n      network == \"testnet\" ||\n      network == \"devnet\" ||\n      network == \"localnet\"\n    ) {\n      this.rpcEndpoint = getFullnodeUrl(network);\n    } else {\n      this.rpcEndpoint = network as string;\n    }\n\n    this.client = new IotaClient({ url: this.rpcEndpoint });\n  }\n\n  getClient() {\n    return this.client;\n  }\n\n  // Query\n  /**\n   * @description Get all vault objects\n   */\n  async getAllVaults(): Promise<VaultInfoList> {\n    // Get objectId from VAULT_MAP and get all vaults\n    const vaultObjectIds = Object.values(VAULT_MAP).map(\n      (v) => v.vault.objectId,\n    );\n    const vaultResults = await this.client.multiGetObjects({\n      ids: vaultObjectIds,\n      options: {\n        showContent: true,\n      },\n    });\n\n    const vaults: VaultInfoList = vaultResults.reduce((acc, res) => {\n      const fields = getObjectFields(res) as VaultResponse;\n      const token = Object.keys(VAULT_MAP).find(\n        (key) =>\n          VAULT_MAP[key as COLLATERAL_COIN].vault.objectId ===\n          res.data?.objectId,\n      );\n      if (!token) return acc;\n\n      const vault = parseVaultObject(token as COLLATERAL_COIN, fields);\n      acc[vault.token] = vault;\n      return acc;\n    }, {} as VaultInfoList);\n\n    return vaults;\n  }\n\n  /**\n   * @description Get prices from oracle\n   */\n  async getPrices() {\n    const res = await this.client.getObject({\n      id: TESTNET_PRICE_FEED_OBJ.objectId,\n      options: {\n        showContent: true,\n      },\n    });\n    const mapObj = getObjectFields(res) as PriceMapResponse;\n    const fields = mapObj.price_map.fields.contents;\n\n    const prices: Record<COIN, number> = {\n      IOTA: 0,\n      stIOTA: 0,\n      VUSD: 1,\n    };\n\n    for (const field of fields) {\n      const coinType = `0x${field.fields.key.fields.name}`;\n      const symbol = getCoinSymbol(coinType);\n      if (!symbol) continue;\n\n      prices[symbol] = formatBigInt(field.fields.value.fields.value);\n    }\n\n    return prices;\n  }\n\n  /**\n   * @description Get Vault<token> object\n   */\n  async getVault(token: COLLATERAL_COIN): Promise<VaultInfo> {\n    const res = await this.client.getObject({\n      id: VAULT_MAP[token].vault.objectId,\n      options: {\n        showContent: true,\n      },\n    });\n    const fields = getObjectFields(res) as VaultResponse;\n\n    return parseVaultObject(token, fields);\n  }\n\n  async getPositionsByDebtor(debtor: string): Promise<PositionInfo[]> {\n    const vaults = await this.getAllVaults();\n    const positions: PositionInfo[] = [];\n    for (const vault of Object.values(vaults)) {\n      const tableId = vault.bottleTableId;\n      const res = await this.client.getDynamicFieldObject({\n        parentId: tableId,\n        name: {\n          type: \"address\",\n          value: debtor,\n        },\n      });\n      const obj = getObjectFields(res);\n      if (!obj) continue;\n\n      const response = obj.value.fields.value as PositionResponse;\n      const position = parsePositionObject(response);\n      if (position) {\n        positions.push(position);\n      }\n    }\n\n    return positions;\n  }\n\n  async getPosition(\n    debtor: string,\n    collateral: COLLATERAL_COIN,\n  ): Promise<PositionInfo | undefined> {\n    const vaultInfo = await this.getVault(collateral);\n    const tableId = vaultInfo.bottleTableId;\n    const res = await this.client.getDynamicFieldObject({\n      parentId: tableId,\n      name: {\n        type: \"address\",\n        value: debtor,\n      },\n    });\n    const obj = getObjectFields(res);\n    if (!obj) return;\n\n    const response = getObjectFields(\n      obj.value.fields.value,\n    ) as PositionResponse;\n    return parsePositionObject(response);\n  }\n\n  async getStabilityPoolBalance(\n    account: string,\n  ): Promise<StabilityPoolBalances> {\n    const tokensRes = await this.client.getOwnedObjects({\n      owner: account,\n      filter: {\n        StructType: `${ORIGINAL_LIQUIDATION_PACKAGE_ID}::stablility_pool::StabilityToken`,\n      },\n      options: {\n        showContent: true,\n      },\n    });\n    if (tokensRes.data) {\n      const vusdBalances = tokensRes.data.map((token) => {\n        if (token.data?.content?.dataType === \"moveObject\") {\n          return Number(\n            (token.data.content.fields as StabilityPoolFields).amount,\n          );\n        } else {\n          return 0;\n        }\n      });\n      return {\n        vusdBalance: vusdBalances.reduce((x, y) => x + y, 0),\n        collBalances: {\n          IOTA: 0,\n          stIOTA: 0,\n        },\n      };\n    } else {\n      return {\n        vusdBalance: 0,\n        collBalances: {\n          IOTA: 0,\n          stIOTA: 0,\n        },\n      };\n    }\n  }\n\n  /**\n   * @description Create a price collector\n   * @param collateral coin symbol, e.g \"IOTA\"\n   */\n  newPriceCollector(\n    tx: Transaction,\n    coinSymbol: COLLATERAL_COIN,\n  ): TransactionResult {\n    return tx.moveCall({\n      target: `${ORACLE_PACKAGE_ID}::collector::new`,\n      typeArguments: [COINS_TYPE_LIST[coinSymbol]],\n    });\n  }\n\n  /**\n   * @description Get a price result\n   * @param collateral coin symbol, e.g \"IOTA\"\n   */\n  aggregatePrice(\n    tx: Transaction,\n    coinSymbol: COLLATERAL_COIN,\n  ): TransactionResult {\n    const [collector] = this.newPriceCollector(tx, coinSymbol);\n    const coinType = COINS_TYPE_LIST[coinSymbol];\n    // TODO: testnet only\n    tx.moveCall({\n      target: `${TESTNET_PRICE_PACKAGE_ID}::testnet_price::self_price`,\n      typeArguments: [coinType],\n      arguments: [tx.sharedObjectRef(TESTNET_PRICE_FEED_OBJ), collector],\n    });\n\n    // aggregate\n    const aggregater = tx.sharedObjectRef(\n      VAULT_MAP[coinSymbol].priceAggregater,\n    );\n    return tx.moveCall({\n      target: `${ORACLE_PACKAGE_ID}::aggregater::aggregate`,\n      typeArguments: [coinType],\n      arguments: [aggregater, collector],\n    });\n  }\n\n  /**\n   * @description Get a request to Mange Position\n   * @param tx\n   * @param collateral coin symbol , e.g \"IOTA\"\n   * @param collateral input coin\n   * @param the amount to borrow\n   * @param repyment input coin (always VUSD)\n   * @param the amount to withdraw\n   * @returns ManageRequest\n   */\n  requestManagePosition(\n    tx: Transaction,\n    coinSymbol: COLLATERAL_COIN,\n    depositCoin: TransactionArgument,\n    borrowAmount: string,\n    repaymentCoin: TransactionArgument,\n    withdrawAmount: string,\n    accountObj?: string | TransactionArgument,\n  ) {\n    const coinType = COINS_TYPE_LIST[coinSymbol];\n    const [accountReq] = accountObj\n      ? tx.moveCall({\n          target: `${FRAMEWORK_PACKAGE_ID}::account::request_with_account`,\n          arguments: [\n            typeof accountObj === \"string\" ? tx.object(accountObj) : accountObj,\n          ],\n        })\n      : tx.moveCall({\n          target: `${FRAMEWORK_PACKAGE_ID}::account::request`,\n        });\n    return tx.moveCall({\n      target: `${CDP_PACKAGE_ID}::manage::request`,\n      typeArguments: [coinType],\n      arguments: [\n        tx.sharedObjectRef(CDP_VERSION_OBJ),\n        accountReq,\n        depositCoin,\n        tx.pure.u64(borrowAmount),\n        repaymentCoin,\n        tx.pure.u64(withdrawAmount),\n      ],\n    });\n  }\n\n  /**\n   * @description Manage Position\n   * @param tx\n   * @param collateral coin symbol , e.g \"IOTA\"\n   * @param manager request, see this.requestManagePosition\n   * @param price result, see this.getPriceResult\n   * @param the position place to insert\n   * @returns [Coin<T>, COIN<VUSD>]\n   */\n  managePosition(\n    tx: Transaction,\n    coinSymbol: COLLATERAL_COIN,\n    manageRequest: TransactionArgument,\n    priceResult?: TransactionArgument,\n    insertionPlace?: string,\n  ): TransactionResult {\n    const vault = VAULT_MAP[coinSymbol].vault;\n    const priceResultOpt = priceResult\n      ? tx.moveCall({\n          target: `0x1::option::some`,\n          typeArguments: [getPriceResultType(coinSymbol)],\n          arguments: [priceResult],\n        })\n      : tx.moveCall({\n          target: `0x1::option::none`,\n          typeArguments: [getPriceResultType(coinSymbol)],\n        });\n    return tx.moveCall({\n      target: `${CDP_PACKAGE_ID}::vault::manage_position`,\n      typeArguments: [COINS_TYPE_LIST[coinSymbol]],\n      arguments: [\n        tx.sharedObjectRef(vault),\n        tx.sharedObjectRef(CDP_VERSION_OBJ),\n        tx.sharedObjectRef(TREASURY_OBJ),\n        tx.sharedObjectRef(CLOCK_OBJ),\n        priceResultOpt,\n        manageRequest,\n        tx.pure.option(\"address\", insertionPlace),\n      ],\n    });\n  }\n\n  depositStabilityPool(\n    tx: Transaction,\n    vusdCoin: TransactionArgument,\n  ): TransactionResult {\n    return tx.moveCall({\n      target: `${LIQUIDATION_PACKAGE_ID}::stablility_pool::deposit`,\n      arguments: [tx.sharedObjectRef(STABILITY_POOL_OBJ), vusdCoin],\n    });\n  }\n\n  withdrawStabilityPool(\n    tx: Transaction,\n    tokens: TransactionArgument[],\n    amount: string,\n  ): TransactionResult {\n    const stabilityPool = tx.sharedObjectRef(STABILITY_POOL_OBJ);\n    const [mainCoin, ...otherCoins] = tokens.map((token) => {\n      const [vusdCoin] = tx.moveCall({\n        target: `${LIQUIDATION_PACKAGE_ID}::stablility_pool::withdraw`,\n        arguments: [stabilityPool, token],\n      });\n      return vusdCoin;\n    });\n    if (otherCoins.length > 0) {\n      tx.mergeCoins(mainCoin, otherCoins);\n    }\n    const [redepositCoin] = tx.splitCoins(mainCoin, [amount]);\n    return this.depositStabilityPool(tx, redepositCoin);\n  }\n}\n","import { COIN } from \"@/types\";\n\nexport const COINS_TYPE_LIST: Record<COIN, string> = {\n  IOTA: \"0x0000000000000000000000000000000000000000000000000000000000000002::iota::IOTA\",\n  stIOTA:\n    \"0x1461ef74f97e83eb024a448ab851f980f4e577a97877069c72b44b5fe9929ee3::cert::CERT\",\n  VUSD: \"0x929065320c756b8a4a841deeed013bd748ee45a28629c4aaafc56d8948ebb081::vusd::VUSD\",\n};\n\nexport const COIN_DECIMALS: Record<COIN, number> = {\n  IOTA: 9,\n  stIOTA: 9,\n  VUSD: 6,\n};\n","import { COLLATERAL_COIN } from \"@/types\";\nimport { SharedObjectRef } from \"@iota/iota-sdk/dist/cjs/bcs/types\";\n\n/// Original Package IDs\n\nexport const ORIGINAL_FRAMEWORK_PACKAGE_ID =\n  \"0x6f8dd0377fe5469cd3456350ca13ae1799655fda06e90191b73ab1c0c0165e8f\";\nexport const ORIGINAL_VUSD_PACKAGE_ID =\n  \"0x929065320c756b8a4a841deeed013bd748ee45a28629c4aaafc56d8948ebb081\";\nexport const ORIGINAL_ORACLE_PACKAGE_ID =\n  \"0x3eb4e0b2c57fe9844db30c6bb2b775ed18fd775dd9d48955b78bcd0ac0ba8954\";\nexport const ORIGINAL_CDP_PACKAGE_ID =\n  \"0x0731a9f5cbdb0a4aea3f540280a1a266502017867734240e29edc813074e7f60\";\nexport const ORIGINAL_LIQUIDATION_PACKAGE_ID =\n  \"0x3b79a39a58128d94bbf2021e36b31485898851909c8167ab0df10fb2824a0f83\";\n\n/// Latest Package IDs\n\nexport const FRAMEWORK_PACKAGE_ID =\n  \"0x6f8dd0377fe5469cd3456350ca13ae1799655fda06e90191b73ab1c0c0165e8f\";\nexport const VUSD_PACKAGE_ID =\n  \"0x929065320c756b8a4a841deeed013bd748ee45a28629c4aaafc56d8948ebb081\";\nexport const ORACLE_PACKAGE_ID =\n  \"0xbc672e6330ab22078715f86e952ef1353d9f9b217c4579e47ce29eaec6f92655\";\nexport const CDP_PACKAGE_ID =\n  \"0xc0d51cf05743fafd185d275d42df0845549af03c0b5f8961a5f33f70c9b5368d\";\nexport const LIQUIDATION_PACKAGE_ID =\n  \"0x3b79a39a58128d94bbf2021e36b31485898851909c8167ab0df10fb2824a0f83\";\n\n/// Shared Objects\n\nexport const CLOCK_OBJ = {\n  objectId:\n    \"0x0000000000000000000000000000000000000000000000000000000000000006\",\n  mutable: false,\n  initialSharedVersion: 1,\n};\n\nexport const TREASURY_OBJ = {\n  objectId:\n    \"0x4e2e41f0158bce26c8e8ccc62be3ab5326d8b294a2bcccfbe0e7298885f66eb7\",\n  mutable: true,\n  initialSharedVersion: 190869396,\n};\n\nexport const CDP_VERSION_OBJ = {\n  objectId:\n    \"0xb67e79921b2b71e77e5bd1adf28c9d47a8ad5bd22e024bbd90797514c39b068d\",\n  mutable: false,\n  initialSharedVersion: 190869403,\n};\n\nexport type VaultObjectInfo = {\n  // symbol: COIN;\n  priceAggregater: SharedObjectRef;\n  vault: SharedObjectRef;\n};\n\nexport const VAULT_MAP: Record<COLLATERAL_COIN, VaultObjectInfo> = {\n  IOTA: {\n    priceAggregater: {\n      objectId:\n        \"0x9f3c9d72993efd5e2e543ad69bdc0bbe1bd9873c3a61fdf32c0cf48660a5f2c8\",\n      mutable: true,\n      initialSharedVersion: 190869399,\n    },\n    vault: {\n      objectId:\n        \"0xbbf7b7667aca64405e8756f6974f41bd648bd1bc40dfc2b1cfe2d6ec419eedb1\",\n      mutable: true,\n      initialSharedVersion: 237544284,\n    },\n  },\n  stIOTA: {\n    priceAggregater: {\n      objectId:\n        \"0x0898681c27fa8912905f97a9803c63d7e56abcbac7175f686325eddb215efebd\",\n      mutable: true,\n      initialSharedVersion: 246871816,\n    },\n    vault: {\n      objectId:\n        \"0xc6b28c98e0c1c6fa282affd3b8db8e9a5ed143aed4e3b5bd1d1bc6f34dad3861\",\n      mutable: true,\n      initialSharedVersion: 246871815,\n    },\n  },\n};\n\nexport const STABILITY_POOL_OBJ: SharedObjectRef = {\n  objectId:\n    \"0x963b3d757dcd5ad14773a503eb481143b64d3686aebdf6a90443d908582188e0\",\n  initialSharedVersion: 252695564,\n  mutable: true,\n};\n\n// only on testnet\nexport const TESTNET_PRICE_PACKAGE_ID =\n  \"0x2de2d918f5940978dc53aae2ea0687a4ca8a6736bd525f15ee17e9529048fa92\";\nexport const TESTNET_PRICE_FEED_OBJ = {\n  objectId:\n    \"0x05cc35b8d331a3893f80b9ca6c70c3b75298e9cbf1b5d707b6d18c40b0b3da5d\",\n  mutable: false,\n  initialSharedVersion: 190869400,\n};\n","import { COIN, COLLATERAL_COIN } from \"@/types\";\nimport { COINS_TYPE_LIST, ORIGINAL_ORACLE_PACKAGE_ID } from \"@/constants\";\nimport { normalizeIotaAddress } from \"@iota/iota-sdk/utils\";\n\nexport function getObjectNames(objectTypes: string[]) {\n  const accept_coin_type = Object.values(COINS_TYPE_LIST);\n  const accept_coin_name = Object.keys(COINS_TYPE_LIST);\n\n  const coinTypeList = objectTypes.map(\n    (type) => type.split(\"<\").pop()?.replace(\">\", \"\") ?? \"\",\n  );\n\n  const objectNameList: string[] = [];\n\n  coinTypeList.forEach((type) => {\n    const typeIndex = accept_coin_type.indexOf(type);\n    const coinName = accept_coin_name[typeIndex];\n    objectNameList.push(coinName ?? \"\");\n  });\n\n  return objectNameList;\n}\n\nexport const getCoinType = (str: string) => {\n  const startIndex = str.indexOf(\"<\");\n  const endIndex = str.lastIndexOf(\">\");\n\n  if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {\n    const coinType = str.slice(startIndex + 1, endIndex);\n    return coinType === \"0x2::iota::IOTA\" ? COINS_TYPE_LIST.IOTA : coinType;\n  }\n\n  return null;\n};\n\nexport const getCoinSymbol = (coinType: string) => {\n  const coin = Object.keys(COINS_TYPE_LIST).find(\n    (key) =>\n      normalizeIotaAddress(COINS_TYPE_LIST[key as COIN]) ===\n      normalizeIotaAddress(coinType),\n  );\n  if (coin) {\n    return coin as COIN;\n  }\n  return undefined;\n};\n\nexport function U64FromBytes(x: number[]) {\n  let u64 = BigInt(0);\n  for (let i = x.length - 1; i >= 0; i--) {\n    u64 = (u64 << BigInt(8)) | BigInt(x[i] ?? 0);\n  }\n  return u64;\n}\n\nexport const formatUnits = (value: bigint, decimals: number) => {\n  let display = value.toString();\n\n  const negative = display.startsWith(\"-\");\n  if (negative) display = display.slice(1);\n\n  display = display.padStart(decimals, \"0\");\n\n  const integer = display.slice(0, display.length - decimals);\n  let fraction = display.slice(display.length - decimals);\n\n  fraction = fraction.replace(/(0+)$/, \"\");\n  return `${negative ? \"-\" : \"\"}${integer || \"0\"}${\n    fraction ? `.${fraction}` : \"\"\n  }`;\n};\n\nexport const formatBigInt = (value: string, decimals: number = 9) => {\n  const formatted = formatUnits(BigInt(value), decimals);\n  return Number(formatted);\n};\n\nexport const parseUnits = (value: number | string, decimals: number) => {\n  let [integer, fraction = \"0\"] =\n    typeof value == \"string\" ? value.split(\".\") : value.toString().split(\".\");\n\n  if (integer === undefined) {\n    return BigInt(0);\n  }\n  const negative = integer.startsWith(\"-\");\n  if (negative) integer = integer.slice(1);\n\n  // trim leading zeros.\n  fraction = fraction.replace(/(0+)$/, \"\");\n\n  // round off if the fraction is larger than the number of decimals.\n  if (decimals === 0) {\n    integer = `${Math.round(Number(`${integer}.${fraction}`))}`;\n    fraction = \"\";\n  } else if (fraction.length > decimals) {\n    const [before, after] = [\n      fraction.slice(0, decimals),\n      fraction.slice(decimals),\n    ];\n    fraction = `${\n      /^0+$/.test(before) ? before.slice(0, before.length - 1) : \"\"\n    }${Math.round(Number(`${before}.${after}`))}`;\n  } else {\n    fraction = fraction.padEnd(decimals, \"0\");\n  }\n\n  return BigInt(`${negative ? \"-\" : \"\"}${integer}${fraction}`);\n};\n\nexport const getPriceResultType = (coinSymbol: COLLATERAL_COIN): string => {\n  return `${ORIGINAL_ORACLE_PACKAGE_ID}::result::PriceResult<${COINS_TYPE_LIST[coinSymbol]}>`;\n};\n","import { IotaClient } from \"@iota/iota-sdk/client\";\nimport {\n  Transaction,\n  TransactionArgument,\n  TransactionResult,\n} from \"@iota/iota-sdk/transactions\";\n\nimport { COINS_TYPE_LIST } from \"@/constants\";\n\nexport function coinIntoBalance(\n  tx: Transaction,\n  coinType: string,\n  coinInput: TransactionArgument | undefined,\n): TransactionResult {\n  if (coinInput) {\n    return tx.moveCall({\n      target: \"0x2::coin::into_balance\",\n      typeArguments: [coinType],\n      arguments: [coinInput],\n    });\n  } else {\n    return tx.moveCall({\n      target: \"0x2::balance::zero\",\n      typeArguments: [coinType],\n    });\n  }\n}\n\nexport function coinFromBalance(\n  tx: Transaction,\n  coinType: string,\n  balanceInput: TransactionArgument,\n): TransactionResult {\n  return tx.moveCall({\n    target: \"0x2::coin::from_balance\",\n    typeArguments: [coinType],\n    arguments: [balanceInput],\n  });\n}\n\nexport async function getInputCoins(\n  tx: Transaction,\n  client: IotaClient,\n  owner: string,\n  coinType: string,\n  ...amounts: string[]\n) {\n  let isZero = true;\n  for (const amount of amounts) {\n    if (Number(amount) > 0) {\n      isZero = false;\n      break;\n    }\n  }\n\n  if (isZero) {\n    return tx.moveCall({\n      target: `0x2::coin::zero`,\n      typeArguments: [coinType],\n    });\n  }\n\n  if (coinType === COINS_TYPE_LIST.IOTA) {\n    return tx.splitCoins(\n      tx.gas,\n      amounts.map((amount) => tx.pure.u64(amount)),\n    );\n  } else {\n    const { data: userCoins } = await client.getCoins({ owner, coinType });\n    const [mainCoin, ...otherCoins] = userCoins.map((coin) =>\n      tx.objectRef({\n        objectId: coin.coinObjectId,\n        version: coin.version,\n        digest: coin.digest,\n      }),\n    );\n    if (!mainCoin) {\n      return tx.moveCall({\n        target: `0x2::coin::zero`,\n        typeArguments: [coinType],\n      });\n    }\n\n    if (otherCoins.length > 0) tx.mergeCoins(mainCoin, otherCoins);\n\n    return tx.splitCoins(\n      mainCoin,\n      amounts.map((amount) => tx.pure.u64(amount)),\n    );\n  }\n}\n\nexport async function getMainCoin(\n  tx: Transaction,\n  client: IotaClient,\n  owner: string,\n  coinType: string,\n) {\n  if (coinType === COINS_TYPE_LIST.IOTA) {\n    return undefined;\n  }\n\n  const { data: userCoins } = await client.getCoins({ owner, coinType });\n  const [mainCoin, ...otherCoins] = userCoins.map((coin) =>\n    tx.objectRef({\n      objectId: coin.coinObjectId,\n      version: coin.version,\n      digest: coin.digest,\n    }),\n  );\n  if (!mainCoin) {\n    return tx.moveCall({\n      target: `0x2::coin::zero`,\n      typeArguments: [coinType],\n    });\n  }\n\n  if (otherCoins.length > 0) tx.mergeCoins(mainCoin, otherCoins);\n  return mainCoin;\n}\n","import {\n  IotaMoveObject,\n  IotaObjectData,\n  IotaObjectResponse,\n  IotaParsedData,\n} from \"@iota/iota-sdk/client\";\nimport type { Infer } from \"superstruct\";\nimport { any, record, string } from \"superstruct\";\n\nexport const ObjectContentFields = record(string(), any());\nexport type ObjectContentFields = Infer<typeof ObjectContentFields>;\n\nexport interface IotaObjectDataWithContent extends IotaObjectData {\n  content: IotaParsedData;\n}\n\nfunction isIotaObjectDataWithContent(\n  data: IotaObjectData,\n): data is IotaObjectDataWithContent {\n  return data.content !== undefined;\n}\n\nexport function getIotaObjectData(\n  resp: IotaObjectResponse,\n): IotaObjectData | null | undefined {\n  return resp.data;\n}\n\nexport function getMoveObject(\n  data: IotaObjectResponse | IotaObjectData,\n): IotaMoveObject | undefined {\n  const obj =\n    \"data\" in data ? getIotaObjectData(data) : (data as IotaObjectData);\n\n  if (\n    !obj ||\n    !isIotaObjectDataWithContent(obj) ||\n    obj.content.dataType !== \"moveObject\"\n  ) {\n    return undefined;\n  }\n\n  return obj.content as IotaMoveObject;\n}\n\nexport function getObjectFields(\n  resp: IotaObjectResponse | IotaMoveObject | IotaObjectData,\n): ObjectContentFields | undefined {\n  if (\"fields\" in resp) {\n    return resp.fields;\n  }\n\n  return getMoveObject(resp)?.fields;\n}\n\nexport const getObjectGenerics = (resp: IotaObjectResponse): string[] => {\n  const objType = resp.data?.type;\n\n  const startIdx = objType?.indexOf?.(\"<\");\n  const endIdx = objType?.lastIndexOf?.(\">\");\n\n  return startIdx ? objType!.slice(startIdx + 1, endIdx).split(\", \") : [];\n};\n","import {\n  COLLATERAL_COIN,\n  PositionInfo,\n  PositionResponse,\n  VaultInfo,\n  VaultResponse,\n} from \"@/types\";\nimport { formatBigInt, getCoinSymbol, getCoinType } from \"./format\";\n\n// Convert response into vault object\nexport const parseVaultObject = (\n  coinSymbol: COLLATERAL_COIN,\n  fields: VaultResponse,\n): VaultInfo => {\n  const vault = {\n    token: coinSymbol,\n    bottleTableSize: fields.position_table.fields.table.fields.size,\n    bottleTableId: fields.position_table.fields.table.fields.id.id,\n    collateralDecimal: Number(fields.decimal),\n    collateralVault: fields.balance,\n    latestRedemptionTime: Number(fields.position_table.fields.timestamp),\n    mintedAmount: fields.limited_supply.fields.supply,\n    maxMintAmount: fields.limited_supply.fields.limit,\n    baseFeeRate: formatBigInt(\n      fields.position_table.fields.fee_rate.fields.value ?? 3_000_000,\n    ),\n    interestRate: formatBigInt(\n      fields.position_table.fields.interest_rate.fields.value,\n    ),\n    minCollateralRatio: formatBigInt(\n      fields.liquidation_config.fields.mcr.fields.value,\n    ),\n    recoveryModeThreshold: formatBigInt(\n      fields.liquidation_config.fields.ccr.fields.value,\n    ),\n    minBottleSize: fields.min_debt_amount,\n  };\n\n  return vault;\n};\n\n// Convert response into position object\nexport const parsePositionObject = (\n  resp: PositionResponse,\n): PositionInfo | undefined => {\n  const collateral = getCoinSymbol(getCoinType(resp.type) ?? \"\");\n  if (!collateral) {\n    return;\n  }\n\n  return {\n    collateral: collateral as COLLATERAL_COIN,\n    collAmount: resp.fields.coll_amount,\n    debtAmount: resp.fields.debt_amount,\n  };\n};\n","import { Transaction } from \"@iota/iota-sdk/transactions\";\nimport { COINS_TYPE_LIST, ORIGINAL_LIQUIDATION_PACKAGE_ID } from \"@/constants\";\nimport { VirtueClient } from \"@/client\";\nimport { COLLATERAL_COIN } from \"@/types\";\nimport { getInputCoins } from \"@/utils\";\nimport { IotaObjectData } from \"@iota/iota-sdk/dist/cjs/client\";\n\n/* ----- Manage Position Builder ----- */\nexport async function buildManagePositionTx(\n  client: VirtueClient,\n  tx: Transaction,\n  sender: string,\n  collateralSymbol: COLLATERAL_COIN,\n  collateralAmount: string,\n  borrowAmount: string,\n  repaymentAmount: string,\n  withrawAmount: string,\n  insertionPlace?: string,\n  accountObjId?: string,\n  recipient?: string,\n) {\n  const iotaClient = client.getClient();\n  const coinType = COINS_TYPE_LIST[collateralSymbol];\n  const [depositCoin] = await getInputCoins(\n    tx,\n    iotaClient,\n    sender,\n    coinType,\n    collateralAmount,\n  );\n  const [repaymentCoin] = await getInputCoins(\n    tx,\n    iotaClient,\n    sender,\n    COINS_TYPE_LIST.VUSD,\n    repaymentAmount,\n  );\n  const [priceResult] =\n    Number(borrowAmount) > 0 || Number(withrawAmount) > 0\n      ? client.aggregatePrice(tx, collateralSymbol)\n      : [undefined];\n  const [manageRequest] = client.requestManagePosition(\n    tx,\n    collateralSymbol,\n    depositCoin,\n    borrowAmount,\n    repaymentCoin,\n    withrawAmount,\n    accountObjId,\n  );\n  const [collCoin, vusdCoin] = client.managePosition(\n    tx,\n    collateralSymbol,\n    manageRequest,\n    priceResult,\n    insertionPlace,\n  );\n  tx.transferObjects([collCoin, vusdCoin], recipient ?? sender);\n}\n\nexport async function buildDepositStabilityPoolTx(\n  client: VirtueClient,\n  tx: Transaction,\n  sender: string,\n  vusdAmount: string,\n  recipient?: string,\n) {\n  const iotaClient = client.getClient();\n  const [inputCoin] = await getInputCoins(\n    tx,\n    iotaClient,\n    sender,\n    COINS_TYPE_LIST.VUSD,\n    vusdAmount,\n  );\n  const [token] = client.depositStabilityPool(tx, inputCoin);\n  tx.transferObjects([token], recipient ?? sender);\n}\n\nexport async function buildWithdrawStabilityPoolTx(\n  client: VirtueClient,\n  tx: Transaction,\n  sender: string,\n  vusdAmount: string,\n  recipient?: string,\n): Promise<boolean> {\n  const iotaClient = client.getClient();\n  const tokensRes = await iotaClient.getOwnedObjects({\n    owner: sender,\n    filter: {\n      StructType: `${ORIGINAL_LIQUIDATION_PACKAGE_ID}::stablility_pool::StabilityToken`,\n    },\n  });\n  if (tokensRes.data) {\n    const tokens = tokensRes.data.map((token) =>\n      tx.objectRef(token.data as IotaObjectData),\n    );\n    const [coin] = client.withdrawStabilityPool(tx, tokens, vusdAmount);\n    tx.transferObjects([coin], recipient ?? sender);\n    return true;\n  } else {\n    return false;\n  }\n}\n"]}