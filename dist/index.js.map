{"version":3,"sources":["/Users/Justa/Desktop/iota-projects/virtue/virtue-sdk/dist/index.js","../src/client.ts","../src/constants/coin.ts","../src/constants/object.ts","../src/utils/format.ts","../src/utils/object.ts","../src/utils/response.ts"],"names":["collector"],"mappings":"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","file":"/Users/Justa/Desktop/iota-projects/virtue/virtue-sdk/dist/index.js","sourcesContent":[null,"import {\n  Transaction,\n  TransactionArgument,\n  TransactionResult,\n} from \"@iota/iota-sdk/transactions\";\nimport { getFullnodeUrl, IotaClient } from \"@iota/iota-sdk/client\";\n\nimport {\n  CDP_PACKAGE_ID,\n  CERT_METADATA_OBJ,\n  CERT_NATIVE_POOL_OBJ,\n  CERT_RULE_PACKAGE_ID,\n  CLOCK_OBJ,\n  COIN_TYPES,\n  FRAMEWORK_PACKAGE_ID,\n  ORACLE_PACKAGE_ID,\n  PYTH_RULE_CONFIG_OBJ,\n  PYTH_RULE_PACKAGE_ID,\n  PYTH_STATE_ID,\n  TREASURY_OBJ,\n  VAULT_MAP,\n  WORMHOLE_STATE_ID,\n} from \"@/constants\";\nimport {\n  VaultInfo,\n  VaultResponse,\n  COLLATERAL_COIN,\n  PositionInfo,\n  VaultInfoList,\n  COIN,\n  StabilityPoolInfo,\n  StabilityPoolBalances,\n  // PositionResponse,\n  // StabilityPoolResponse,\n} from \"@/types\";\nimport {\n  // formatBigInt,\n  getObjectFields,\n  getPriceResultType,\n  // parsePositionObject,\n  // parseStabilityPoolObject,\n  parseVaultObject,\n} from \"@/utils\";\nimport {\n  IotaPriceServiceConnection,\n  IotaPythClient,\n} from \"@pythnetwork/pyth-iota-js\";\nimport { bcs } from \"@iota/iota-sdk/bcs\";\nimport { isValidIotaAddress } from \"@iota/iota-sdk/utils\";\n\nexport class VirtueClient {\n  /**\n   * @description a TS wrapper over Virtue CDP client.\n   * @param network connection to fullnode: 'mainnet' | 'testnet' | 'devnet' | 'localnet' | string\n   * @param owner (optional) address of the current user (default: DUMMY_ADDRESS)\n   */\n  private rpcEndpoint: string;\n  private iotaClient: IotaClient;\n  private pythConnection: IotaPriceServiceConnection;\n  private pythClient: IotaPythClient;\n  private transaction: Transaction;\n  public sender: string;\n\n  constructor(inputs: { rpcUrl?: string; sender: string }) {\n    const { rpcUrl, sender } = inputs;\n    this.rpcEndpoint = rpcUrl ?? getFullnodeUrl(\"mainnet\");\n    if (!isValidIotaAddress(sender)) {\n      throw new Error(\"Invalid sender address\");\n    }\n    this.sender = sender;\n    this.iotaClient = new IotaClient({ url: this.rpcEndpoint });\n    this.pythConnection = new IotaPriceServiceConnection(\n      \"https://hermes.pyth.network\",\n    );\n    /* eslint-disable  @typescript-eslint/no-explicit-any */\n    this.pythClient = new IotaPythClient(\n      this.iotaClient as any,\n      PYTH_STATE_ID,\n      WORMHOLE_STATE_ID,\n    );\n    this.transaction = new Transaction();\n  }\n\n  /* ----- Getter ----- */\n\n  /**\n   * @description Get this.iotaClient\n   */\n  getIotaClient(): IotaClient {\n    return this.iotaClient;\n  }\n\n  /**\n   * @description Get this.pythConnection\n   */\n  getPythConnection(): IotaPriceServiceConnection {\n    return this.pythConnection;\n  }\n\n  /**\n   * @description Get this.pythClient\n   */\n  getPythClient(): IotaPythClient {\n    return this.pythClient;\n  }\n\n  /* ----- Query ----- */\n\n  /**\n   * @description Get all vault objects\n   */\n  async getAllVaults(): Promise<VaultInfoList> {\n    // Get objectId from VAULT_MAP and get all vaults\n    const vaultObjectIds = Object.values(VAULT_MAP).map(\n      (v) => v.vault.objectId,\n    );\n    const vaultResults = await this.iotaClient.multiGetObjects({\n      ids: vaultObjectIds,\n      options: {\n        showContent: true,\n      },\n    });\n\n    const vaults: VaultInfoList = vaultResults.reduce((acc, res) => {\n      const fields = getObjectFields(res) as VaultResponse;\n      const token = Object.keys(VAULT_MAP).find(\n        (key) =>\n          VAULT_MAP[key as COLLATERAL_COIN].vault.objectId ===\n          res.data?.objectId,\n      );\n      if (!token) return acc;\n\n      const vault = parseVaultObject(token as COLLATERAL_COIN, fields);\n      acc[vault.token] = vault;\n      return acc;\n    }, {} as VaultInfoList);\n\n    return vaults;\n  }\n\n  /**\n   * @description Get Vault<token> object\n   */\n  async getVault(token: COLLATERAL_COIN): Promise<VaultInfo> {\n    const res = await this.iotaClient.getObject({\n      id: VAULT_MAP[token].vault.objectId,\n      options: {\n        showContent: true,\n      },\n    });\n    const fields = getObjectFields(res) as VaultResponse;\n\n    return parseVaultObject(token, fields);\n  }\n\n  /**\n   * @description Get debtor's position data\n   */\n  async getDebtorPositions(debtor?: string): Promise<PositionInfo[]> {\n    const tx = new Transaction();\n    const clockObj = tx.sharedObjectRef(CLOCK_OBJ);\n    const tokenList = Object.keys(VAULT_MAP) as COLLATERAL_COIN[];\n    const debtorAddr = debtor ?? this.sender;\n    if (!isValidIotaAddress(debtorAddr)) {\n      throw new Error(\"Invalid debtor address\");\n    }\n    tokenList.map((token) => {\n      tx.moveCall({\n        target: `${CDP_PACKAGE_ID}::vault::try_get_position_data`,\n        typeArguments: [COIN_TYPES[token]],\n        arguments: [\n          tx.sharedObjectRef(VAULT_MAP[token].vault),\n          tx.pure.address(debtorAddr),\n          clockObj,\n        ],\n      });\n    });\n\n    const res = await this.iotaClient.devInspectTransactionBlock({\n      transactionBlock: tx,\n      sender: debtor ?? this.sender,\n    });\n    if (!res.results) return [];\n\n    return res.results.map((value, idx) => {\n      const collateral = tokenList[idx];\n      if (value.returnValues) {\n        const [collReturn, debtReturn] = value.returnValues;\n        return {\n          collateral,\n          collAmount: collReturn\n            ? bcs.u64().parse(Uint8Array.from(collReturn[0]))\n            : \"0\",\n          debtAmount: debtReturn\n            ? bcs.u64().parse(Uint8Array.from(debtReturn[0]))\n            : \"0\",\n        };\n      } else {\n        return {\n          collateral: tokenList[idx],\n          collAmount: \"0\",\n          debtAmount: \"0\",\n        };\n      }\n    });\n  }\n\n  async getStabilityPool(): Promise<StabilityPoolInfo> {\n    // TODO: fetch StabilityPool object\n    return { vusdBalance: 0 };\n  }\n\n  async getStabilityPoolBalances(\n    account?: string,\n  ): Promise<StabilityPoolBalances> {\n    // TODO: devInspect stability getter fun\n    const accountAddr = account ?? this.sender;\n    if (!isValidIotaAddress(accountAddr)) {\n      throw new Error(\"Invalid account address\");\n    }\n    return {\n      vusdBalance: 0,\n      collBalances: {\n        IOTA: 0,\n        stIOTA: 0,\n      },\n    };\n  }\n\n  /* ----- Transaction Utils ----- */\n\n  /**\n   * @description new zero coin\n   */\n  zeroCoin(coinSymbol: COIN): TransactionResult {\n    return this.transaction.moveCall({\n      target: \"0x2::coin::zero\",\n      typeArguments: [COIN_TYPES[coinSymbol]],\n    });\n  }\n\n  /**\n   * @description split the needed coins\n   */\n  async splitInputCoins(\n    coinSymbol: COIN,\n    ...amounts: string[]\n  ): Promise<TransactionResult> {\n    const totalAmount = amounts.reduce(\n      (sum, amount) => sum + Number(amount),\n      0,\n    );\n    if (totalAmount === 0) {\n      return this.zeroCoin(coinSymbol);\n    } else {\n      if (coinSymbol === \"IOTA\") {\n        return this.transaction.splitCoins(\n          this.transaction.gas,\n          amounts.map((amount) => this.transaction.pure.u64(amount)),\n        );\n      } else {\n        const coinType = COIN_TYPES[coinSymbol];\n        const { data: userCoins } = await this.iotaClient.getCoins({\n          owner: this.sender,\n          coinType,\n        });\n        const [mainCoin, ...otherCoins] = userCoins.map((coin) =>\n          this.transaction.objectRef({\n            objectId: coin.coinObjectId,\n            version: coin.version,\n            digest: coin.digest,\n          }),\n        );\n        if (!mainCoin) {\n          throw new Error(\"Not enough balance\");\n        }\n\n        if (otherCoins.length > 0)\n          this.transaction.mergeCoins(mainCoin, otherCoins);\n\n        return this.transaction.splitCoins(\n          mainCoin,\n          amounts.map((amount) => this.transaction.pure.u64(amount)),\n        );\n      }\n    }\n  }\n\n  /* ----- Transaction Methods ----- */\n\n  /**\n   * @description Reset this.transaction\n   */\n  resetTransaction() {\n    this.transaction = new Transaction();\n  }\n\n  /**\n   * @description return Transaction\n   * @returns Transaction\n   */\n  getTransaction(): Transaction {\n    return this.transaction;\n  }\n\n  /**\n   * @description Create a price collector\n   * @param collateral coin symbol, e.g \"IOTA\"\n   * @return [PriceCollector]\n   */\n  newPriceCollector(collateralSymbol: COLLATERAL_COIN): TransactionResult {\n    return this.transaction.moveCall({\n      target: `${ORACLE_PACKAGE_ID}::collector::new`,\n      typeArguments: [COIN_TYPES[collateralSymbol]],\n    });\n  }\n\n  /**\n   * @description Get a price result\n   * @param collateral coin symbol, e.g \"IOTA\"\n   * @return [PriceResult]\n   */\n  async aggregatePrice(\n    collateralSymbol: COLLATERAL_COIN,\n  ): Promise<TransactionResult> {\n    const [collector] = this.newPriceCollector(collateralSymbol);\n    const coinType = COIN_TYPES[collateralSymbol];\n    const vaultInfo = VAULT_MAP[collateralSymbol];\n    if (vaultInfo.pythPriceId) {\n      const updateData = await this.pythConnection.getPriceFeedsUpdateData([\n        vaultInfo.pythPriceId,\n      ]);\n      const [priceInfoObjId] = await this.pythClient.updatePriceFeeds(\n        this.transaction as any,\n        updateData,\n        [vaultInfo.pythPriceId],\n      );\n      this.transaction.moveCall({\n        target: `${PYTH_RULE_PACKAGE_ID}::pyth_rule::feed`,\n        typeArguments: [coinType],\n        arguments: [\n          collector,\n          this.transaction.sharedObjectRef(PYTH_RULE_CONFIG_OBJ),\n          this.transaction.sharedObjectRef(CLOCK_OBJ),\n          this.transaction.object(PYTH_STATE_ID),\n          this.transaction.object(priceInfoObjId),\n        ],\n      });\n      return this.transaction.moveCall({\n        target: `${ORACLE_PACKAGE_ID}::aggregater::aggregate`,\n        typeArguments: [coinType],\n        arguments: [\n          this.transaction.sharedObjectRef(vaultInfo.priceAggregater),\n          collector,\n        ],\n      });\n    } else if (collateralSymbol === \"stIOTA\") {\n      const [collector] = this.newPriceCollector(\"stIOTA\");\n      const [iotaPriceResult] = await this.aggregatePrice(\"IOTA\");\n      this.transaction.moveCall({\n        target: `${CERT_RULE_PACKAGE_ID}::cert_rule::feed`,\n        arguments: [\n          collector,\n          iotaPriceResult,\n          this.transaction.sharedObjectRef(CERT_NATIVE_POOL_OBJ),\n          this.transaction.sharedObjectRef(CERT_METADATA_OBJ),\n        ],\n      });\n      return this.transaction.moveCall({\n        target: `${ORACLE_PACKAGE_ID}::aggregater::aggregate`,\n        typeArguments: [COIN_TYPES.stIOTA],\n        arguments: [\n          this.transaction.sharedObjectRef(vaultInfo.priceAggregater),\n          collector,\n        ],\n      });\n    } else {\n      return this.aggregatePrice(\"IOTA\");\n    }\n  }\n\n  /**\n   * @description Get a request to Mange Position\n   * @param collateralSymbol: collateral coin symbol , e.g \"IOTA\"\n   * @param depositCoin: collateral input coin\n   * @param borrowAmount: the amount to borrow\n   * @param repaymentCoin: repyment input coin (always VUSD)\n   * @param withdrawAmount: the amount to withdraw\n   * @param accountObj (optional): account object id or transaction argument\n   * @returns [UpdateRequest]\n   */\n  debtorRequest(inputs: {\n    collateralSymbol: COLLATERAL_COIN;\n    depositCoin: TransactionArgument;\n    borrowAmount: string;\n    repaymentCoin: TransactionArgument;\n    withdrawAmount: string;\n    accountObj?: string | TransactionArgument;\n  }): TransactionResult {\n    const {\n      collateralSymbol,\n      depositCoin,\n      borrowAmount,\n      repaymentCoin,\n      withdrawAmount,\n      accountObj,\n    } = inputs;\n    const coinType = COIN_TYPES[collateralSymbol];\n    const vaultId = VAULT_MAP[collateralSymbol].vault.objectId;\n    const [accountReq] = accountObj\n      ? this.transaction.moveCall({\n          target: `${FRAMEWORK_PACKAGE_ID}::account::request_with_account`,\n          arguments: [\n            typeof accountObj === \"string\"\n              ? this.transaction.object(accountObj)\n              : accountObj,\n          ],\n        })\n      : this.transaction.moveCall({\n          target: `${FRAMEWORK_PACKAGE_ID}::account::request`,\n        });\n    return this.transaction.moveCall({\n      target: `${CDP_PACKAGE_ID}::request::debtor_request`,\n      typeArguments: [coinType],\n      arguments: [\n        accountReq,\n        this.transaction.sharedObjectRef(TREASURY_OBJ),\n        this.transaction.pure.id(vaultId),\n        depositCoin,\n        this.transaction.pure.u64(borrowAmount),\n        repaymentCoin,\n        this.transaction.pure.u64(withdrawAmount),\n      ],\n    });\n  }\n\n  /**\n   * @description Manage Position\n   * @param collateralSymbol: collateral coin symbol , e.g \"IOTA\"\n   * @param updateRequest: manager request, ex: see this.debtorRequest\n   * @param priceResult: price result, see this.aggregatePrice\n   * @returns [Coin<T>, COIN<VUSD>]\n   */\n  updatePosition(inputs: {\n    collateralSymbol: COLLATERAL_COIN;\n    updateRequest: TransactionArgument;\n    priceResult?: TransactionArgument;\n  }): TransactionResult {\n    const { collateralSymbol, updateRequest, priceResult } = inputs;\n    const vault = VAULT_MAP[collateralSymbol].vault;\n    const priceResultOpt = priceResult\n      ? this.transaction.moveCall({\n          target: `0x1::option::some`,\n          typeArguments: [getPriceResultType(collateralSymbol)],\n          arguments: [priceResult],\n        })\n      : this.transaction.moveCall({\n          target: `0x1::option::none`,\n          typeArguments: [getPriceResultType(collateralSymbol)],\n        });\n    return this.transaction.moveCall({\n      target: `${CDP_PACKAGE_ID}::vault::update_position`,\n      typeArguments: [COIN_TYPES[collateralSymbol]],\n      arguments: [\n        this.transaction.sharedObjectRef(vault),\n        this.transaction.sharedObjectRef(TREASURY_OBJ),\n        this.transaction.sharedObjectRef(CLOCK_OBJ),\n        priceResultOpt,\n        updateRequest,\n      ],\n    });\n  }\n\n  depositStabilityPool(inputs: { vusdCoin: TransactionArgument }) {\n    // TODO: PTB of deposit SP\n    const { vusdCoin } = inputs;\n    this.transaction.transferObjects([vusdCoin], this.sender);\n  }\n\n  withdrawStabilityPool(inputs: { amount: string }): TransactionResult {\n    // TODO: PTB of withdraw SP\n    const { amount } = inputs;\n    return [this.transaction.pure.u64(amount)] as TransactionResult;\n  }\n\n  /* ----- Transaction Methods ----- */\n\n  /**\n   * @description build and return Transaction of manage position\n   * @param collateralSymbol: collateral coin symbol , e.g \"IOTA\"\n   * @param depositAmount: how much amount to deposit (collateral)\n   * @param borrowAmount: how much amout to borrow (VUSD)\n   * @param repaymentAmount: how much amount to repay (VUSD)\n   * @param withdrawAmount: how much amount to withdraw (collateral)\n   * @param accountObjId: the Account object to hold position (undefined if just use EOA)\n   * @param recipient (optional): the recipient of the output coins\n   * @returns Transaction\n   */\n  async buildManagePositionTransaction(inputs: {\n    collateralSymbol: COLLATERAL_COIN;\n    depositAmount: string;\n    borrowAmount: string;\n    repaymentAmount: string;\n    withdrawAmount: string;\n    accountObjId?: string;\n    recipient?: string | \"StabilityPool\";\n  }): Promise<Transaction> {\n    this.resetTransaction();\n    const {\n      collateralSymbol,\n      depositAmount,\n      borrowAmount,\n      repaymentAmount,\n      withdrawAmount,\n      accountObjId,\n      recipient,\n    } = inputs;\n    const coinType = COIN_TYPES[collateralSymbol];\n    if (!this.sender) throw new Error(\"Sender is not set\");\n    const [depositCoin] = await this.splitInputCoins(\n      collateralSymbol,\n      depositAmount,\n    );\n    const [repaymentCoin] = await this.splitInputCoins(\"VUSD\", repaymentAmount);\n    const [priceResult] =\n      Number(borrowAmount) > 0 || Number(withdrawAmount) > 0\n        ? await this.aggregatePrice(collateralSymbol)\n        : [undefined];\n    const [updateRequest] = this.debtorRequest({\n      collateralSymbol,\n      depositCoin,\n      borrowAmount,\n      repaymentCoin,\n      withdrawAmount,\n      accountObj: accountObjId,\n    });\n    const [collCoin, vusdCoin] = this.updatePosition({\n      collateralSymbol,\n      updateRequest,\n      priceResult,\n    });\n    if (Number(withdrawAmount) > 0) {\n      this.transaction.transferObjects([collCoin], recipient ?? this.sender);\n    } else {\n      this.transaction.moveCall({\n        target: \"0x2::coin::destroy_zero\",\n        typeArguments: [coinType],\n        arguments: [collCoin],\n      });\n    }\n    if (Number(borrowAmount) > 0) {\n      if (recipient === \"StabilityPool\") {\n        this.depositStabilityPool({ vusdCoin });\n      } else {\n        this.transaction.transferObjects([vusdCoin], recipient ?? this.sender);\n      }\n    } else {\n      this.transaction.moveCall({\n        target: \"0x2::coin::destroy_zero\",\n        typeArguments: [COIN_TYPES.VUSD],\n        arguments: [vusdCoin],\n      });\n    }\n    return this.getTransaction();\n  }\n\n  /**\n   * @description build and return Transaction of deposit stability pool\n   * @param depositAmount: how much amount to deposit (collateral)\n   * @returns Transaction\n   */\n  async buildDepositStabilityPoolTransaction(inputs: {\n    depositAmount: string;\n  }): Promise<Transaction> {\n    this.resetTransaction();\n    const { depositAmount } = inputs;\n    const [vusdCoin] = await this.splitInputCoins(\"VUSD\", depositAmount);\n    this.depositStabilityPool({ vusdCoin });\n    const tx = this.getTransaction();\n    this.resetTransaction();\n    return tx;\n  }\n\n  /**\n   * @description build and return Transaction of withdraw stability pool\n   * @param withdrawAmount: how much amount to withdraw (collateral)\n   * @returns Transaction\n   */\n  async buildWithdrawStabilityPoolTransaction(inputs: {\n    withdrawAmount: string;\n  }): Promise<Transaction> {\n    this.resetTransaction();\n    const { withdrawAmount: amount } = inputs;\n    this.withdrawStabilityPool({ amount });\n    const tx = this.getTransaction();\n    this.resetTransaction();\n    return tx;\n  }\n}\n","import { COIN } from \"@/types\";\n\nexport const COIN_TYPES: Record<COIN, string> = {\n  IOTA: \"0x0000000000000000000000000000000000000000000000000000000000000002::iota::IOTA\",\n  stIOTA:\n    \"0x346778989a9f57480ec3fee15f2cd68409c73a62112d40a3efd13987997be68c::cert::CERT\",\n  VUSD: \"0xd3b63e603a78786facf65ff22e79701f3e824881a12fa3268d62a75530fe904f::vusd::VUSD\",\n};\n\nexport const COIN_DECIMALS: Record<COIN, number> = {\n  IOTA: 9,\n  stIOTA: 9,\n  VUSD: 6,\n};\n","import { COLLATERAL_COIN } from \"@/types\";\n\n/// Original Package IDs\n\nexport const ORIGINAL_FRAMEWORK_PACKAGE_ID =\n  \"0x7400af41a9b9d7e4502bc77991dbd1171f90855564fd28afa172a5057beb083b\";\nexport const ORIGINAL_VUSD_PACKAGE_ID =\n  \"0xd3b63e603a78786facf65ff22e79701f3e824881a12fa3268d62a75530fe904f\";\nexport const ORIGINAL_ORACLE_PACKAGE_ID =\n  \"0x7eebbee92f64ba2912bdbfba1864a362c463879fc5b3eacc735c1dcb255cc2cf\";\nexport const ORIGINAL_CDP_PACKAGE_ID =\n  \"0xcdeeb40cd7ffd7c3b741f40a8e11cb784a5c9b588ce993d4ab86479072386ba1\";\n// export const ORIGINAL_LIQUIDATION_PACKAGE_ID =\n//   \"0x3b79a39a58128d94bbf2021e36b31485898851909c8167ab0df10fb2824a0f83\";\n\n/// Latest Package IDs\n\nexport const FRAMEWORK_PACKAGE_ID =\n  \"0x7400af41a9b9d7e4502bc77991dbd1171f90855564fd28afa172a5057beb083b\";\nexport const VUSD_PACKAGE_ID =\n  \"0xd3b63e603a78786facf65ff22e79701f3e824881a12fa3268d62a75530fe904f\";\nexport const ORACLE_PACKAGE_ID =\n  \"0x7eebbee92f64ba2912bdbfba1864a362c463879fc5b3eacc735c1dcb255cc2cf\";\nexport const CDP_PACKAGE_ID =\n  \"0x34fa327ee4bb581d81d85a8c40b6a6b4260630a0ef663acfe6de0e8ca471dd22 \";\n// export const LIQUIDATION_PACKAGE_ID =\n//   \"0x3b79a39a58128d94bbf2021e36b31485898851909c8167ab0df10fb2824a0f83\";\n\n/// Shared Objects\n\nexport const CLOCK_OBJ: SharedObjectRef = {\n  objectId:\n    \"0x0000000000000000000000000000000000000000000000000000000000000006\",\n  mutable: false,\n  initialSharedVersion: 1,\n};\n\nexport const TREASURY_OBJ: SharedObjectRef = {\n  objectId:\n    \"0x81f525f4fa5b2d3cf58677d3e39aabc4b0a1ca25cbba605033cfe417e47b0a16\",\n  mutable: true,\n  initialSharedVersion: 22329876,\n};\n\nexport type SharedObjectRef = {\n  objectId: string;\n  mutable: boolean;\n  initialSharedVersion: number;\n};\n\nexport type VaultObjectInfo = {\n  // symbol: COIN;\n  priceAggregater: SharedObjectRef;\n  vault: SharedObjectRef;\n  pythPriceId?: string;\n};\n\nexport const VAULT_MAP: Record<COLLATERAL_COIN, VaultObjectInfo> = {\n  IOTA: {\n    priceAggregater: {\n      objectId:\n        \"0x052c40b4e8f16df5238457f3a7b3b0eeaa49c6bc8acc22f6a7790ab32495b2c6\",\n      mutable: false,\n      initialSharedVersion: 22329880,\n    },\n    vault: {\n      objectId:\n        \"0xaf306be8419cf059642acdba3b4e79a5ae893101ae62c8331cefede779ef48d5\",\n      mutable: true,\n      initialSharedVersion: 22329895,\n    },\n    pythPriceId:\n      \"0xc7b72e5d860034288c9335d4d325da4272fe50c92ab72249d58f6cbba30e4c44\",\n  },\n  stIOTA: {\n    priceAggregater: {\n      objectId:\n        \"0x8c730f64aa369eed69ddf7eea39c78bf0afd3f9fbb4ee0dfe457f6dea5a0f4ed\",\n      mutable: false,\n      initialSharedVersion: 22329881,\n    },\n    vault: {\n      objectId:\n        \"0xc9cb494657425f350af0948b8509efdd621626922e9337fd65eb161ec33de259\",\n      mutable: true,\n      initialSharedVersion: 22329896,\n    },\n  },\n};\n\nexport const PYTH_STATE_ID =\n  \"0x6bc33855c7675e006f55609f61eebb1c8a104d8973a698ee9efd3127c210b37f\";\nexport const WORMHOLE_STATE_ID =\n  \"0xd43b448afc9dd01deb18273ec39d8f27ddd4dd46b0922383874331771b70df73\";\nexport const PYTH_RULE_PACKAGE_ID =\n  \"0xed5a8dac2ca41ae9bdc1c7f778b0949d3e26c18c51ed284c4cfa4030d0bb64c2\";\nexport const PYTH_RULE_CONFIG_OBJ: SharedObjectRef = {\n  objectId:\n    \"0xbcc4f6e3ca3d4a83eac39282ab7d1cb086924c58bef825d69c33b00fea1105b8\",\n  initialSharedVersion: 22329882,\n  mutable: false,\n};\n\nexport const CERT_RULE_PACKAGE_ID =\n  \"0x01edb9afe0663b8762d2e0a18923df8bee98d28f3a60ac56ff67a27bbf53a7ac\";\nexport const CERT_NATIVE_POOL_OBJ: SharedObjectRef = {\n  objectId:\n    \"0x02d641d7b021b1cd7a2c361ac35b415ae8263be0641f9475ec32af4b9d8a8056\",\n  initialSharedVersion: 19,\n  mutable: false,\n};\nexport const CERT_METADATA_OBJ: SharedObjectRef = {\n  objectId:\n    \"0x8c25ec843c12fbfddc7e25d66869f8639e20021758cac1a3db0f6de3c9fda2ed\",\n  initialSharedVersion: 19,\n  mutable: false,\n};\n\n// export const STABILITY_POOL_OBJ: SharedObjectRef = {\n//   objectId:\n//     \"0x963b3d757dcd5ad14773a503eb481143b64d3686aebdf6a90443d908582188e0\",\n//   initialSharedVersion: 252695564,\n//   mutable: true,\n// };\n","import { COIN, COLLATERAL_COIN } from \"@/types\";\nimport { COIN_TYPES, ORIGINAL_ORACLE_PACKAGE_ID } from \"@/constants\";\nimport { normalizeIotaAddress } from \"@iota/iota-sdk/utils\";\n\nexport function getObjectNames(objectTypes: string[]) {\n  const accept_coin_type = Object.values(COIN_TYPES);\n  const accept_coin_name = Object.keys(COIN_TYPES);\n\n  const coinTypeList = objectTypes.map(\n    (type) => type.split(\"<\").pop()?.replace(\">\", \"\") ?? \"\",\n  );\n\n  const objectNameList: string[] = [];\n\n  coinTypeList.forEach((type) => {\n    const typeIndex = accept_coin_type.indexOf(type);\n    const coinName = accept_coin_name[typeIndex];\n    objectNameList.push(coinName ?? \"\");\n  });\n\n  return objectNameList;\n}\n\nexport const getCoinType = (str: string) => {\n  const startIndex = str.indexOf(\"<\");\n  const endIndex = str.lastIndexOf(\">\");\n\n  if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {\n    const coinType = str.slice(startIndex + 1, endIndex);\n    return coinType === \"0x2::iota::IOTA\" ? COIN_TYPES.IOTA : coinType;\n  }\n\n  return null;\n};\n\nexport const getCoinSymbol = (coinType: string) => {\n  const coin = Object.keys(COIN_TYPES).find(\n    (key) =>\n      normalizeIotaAddress(COIN_TYPES[key as COIN]) ===\n      normalizeIotaAddress(coinType),\n  );\n  if (coin) {\n    return coin as COIN;\n  }\n  return undefined;\n};\n\nexport function U64FromBytes(x: number[]) {\n  let u64 = BigInt(0);\n  for (let i = x.length - 1; i >= 0; i--) {\n    u64 = (u64 << BigInt(8)) | BigInt(x[i] ?? 0);\n  }\n  return u64;\n}\n\nexport const formatUnits = (value: bigint, decimals: number) => {\n  let display = value.toString();\n\n  const negative = display.startsWith(\"-\");\n  if (negative) display = display.slice(1);\n\n  display = display.padStart(decimals, \"0\");\n\n  const integer = display.slice(0, display.length - decimals);\n  let fraction = display.slice(display.length - decimals);\n\n  fraction = fraction.replace(/(0+)$/, \"\");\n  return `${negative ? \"-\" : \"\"}${integer || \"0\"}${\n    fraction ? `.${fraction}` : \"\"\n  }`;\n};\n\nexport const formatBigInt = (value: string, decimals: number = 9) => {\n  const formatted = formatUnits(BigInt(value), decimals);\n  return Number(formatted);\n};\n\nexport const parseUnits = (value: number | string, decimals: number) => {\n  let [integer, fraction = \"0\"] =\n    typeof value == \"string\" ? value.split(\".\") : value.toString().split(\".\");\n\n  if (integer === undefined) {\n    return BigInt(0);\n  }\n  const negative = integer.startsWith(\"-\");\n  if (negative) integer = integer.slice(1);\n\n  // trim leading zeros.\n  fraction = fraction.replace(/(0+)$/, \"\");\n\n  // round off if the fraction is larger than the number of decimals.\n  if (decimals === 0) {\n    integer = `${Math.round(Number(`${integer}.${fraction}`))}`;\n    fraction = \"\";\n  } else if (fraction.length > decimals) {\n    const [before, after] = [\n      fraction.slice(0, decimals),\n      fraction.slice(decimals),\n    ];\n    fraction = `${\n      /^0+$/.test(before) ? before.slice(0, before.length - 1) : \"\"\n    }${Math.round(Number(`${before}.${after}`))}`;\n  } else {\n    fraction = fraction.padEnd(decimals, \"0\");\n  }\n\n  return BigInt(`${negative ? \"-\" : \"\"}${integer}${fraction}`);\n};\n\nexport const getPriceResultType = (coinSymbol: COLLATERAL_COIN): string => {\n  return `${ORIGINAL_ORACLE_PACKAGE_ID}::result::PriceResult<${COIN_TYPES[coinSymbol]}>`;\n};\n","import {\n  IotaMoveObject,\n  IotaObjectData,\n  IotaObjectResponse,\n  IotaParsedData,\n} from \"@iota/iota-sdk/client\";\nimport type { Infer } from \"superstruct\";\nimport { any, record, string } from \"superstruct\";\n\nexport const ObjectContentFields = record(string(), any());\nexport type ObjectContentFields = Infer<typeof ObjectContentFields>;\n\nexport interface IotaObjectDataWithContent extends IotaObjectData {\n  content: IotaParsedData;\n}\n\nfunction isIotaObjectDataWithContent(\n  data: IotaObjectData,\n): data is IotaObjectDataWithContent {\n  return data.content !== undefined;\n}\n\nexport function getIotaObjectData(\n  resp: IotaObjectResponse,\n): IotaObjectData | null | undefined {\n  return resp.data;\n}\n\nexport function getMoveObject(\n  data: IotaObjectResponse | IotaObjectData,\n): IotaMoveObject | undefined {\n  const obj =\n    \"data\" in data ? getIotaObjectData(data) : (data as IotaObjectData);\n\n  if (\n    !obj ||\n    !isIotaObjectDataWithContent(obj) ||\n    obj.content.dataType !== \"moveObject\"\n  ) {\n    return undefined;\n  }\n\n  return obj.content as IotaMoveObject;\n}\n\nexport function getObjectFields(\n  resp: IotaObjectResponse | IotaMoveObject | IotaObjectData,\n): ObjectContentFields | undefined {\n  if (\"fields\" in resp) {\n    return resp.fields;\n  }\n\n  return getMoveObject(resp)?.fields;\n}\n\nexport const getObjectGenerics = (resp: IotaObjectResponse): string[] => {\n  const objType = resp.data?.type;\n\n  const startIdx = objType?.indexOf?.(\"<\");\n  const endIdx = objType?.lastIndexOf?.(\">\");\n\n  return startIdx ? objType!.slice(startIdx + 1, endIdx).split(\", \") : [];\n};\n","import {\n  COLLATERAL_COIN,\n  // PositionInfo,\n  // PositionResponse,\n  // StabilityPoolInfo,\n  // StabilityPoolResponse,\n  VaultInfo,\n  VaultResponse,\n} from \"@/types\";\nimport { formatBigInt } from \"./format\";\n\n// Convert response into vault object\nexport const parseVaultObject = (\n  coinSymbol: COLLATERAL_COIN,\n  fields: VaultResponse,\n): VaultInfo => {\n  return {\n    token: coinSymbol,\n    positionTableSize: fields.position_table.fields.size,\n    collateralDecimal: Number(fields.decimal),\n    collateralBalance: fields.balance,\n    supply: fields.limited_supply.fields.supply,\n    maxSupply: fields.limited_supply.fields.limit,\n    interestRate: formatBigInt(fields.interest_rate.fields.value, 18),\n    minCollateralRatio: formatBigInt(fields.min_collateral_ratio.fields.value),\n  };\n};\n\n// Convert response into position object\n// export const parsePositionObject = (\n//   resp: PositionResponse,\n// ): PositionInfo | undefined => {\n//   const collateral = getCoinSymbol(getCoinType(resp.type) ?? \"\");\n//   if (!collateral) {\n//     return;\n//   }\n\n//   return {\n//     collateral: collateral as COLLATERAL_COIN,\n//     collAmount: resp.fields.coll_amount,\n//     debtAmount: (\n//       BigInt(resp.fields.debt_amount) + BigInt(resp.fields.interest_buffer)\n//     ).toString(),\n//   };\n// };\n\n// export const parseStabilityPoolObject = (\n//   fields: StabilityPoolResponse,\n// ): StabilityPoolInfo => {\n//   return {\n//     vusdBalance: formatBigInt(fields.balance, COIN_DECIMALS.VUSD),\n//   };\n// };\n"]}
